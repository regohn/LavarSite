<!DOCTYPE html>
<html>
<head>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const table = document.querySelector("#tableContainer #dataTable");
      if (!table) return;

      const rows = table.querySelectorAll("tbody tr");

      // Get the index of the "Date Paid" column (case-insensitive)
      const headers = Array.from(table.querySelectorAll("thead th"));
      const datePaidIndex = headers.findIndex(
        th => th.textContent.trim().toLowerCase() === "DATE PAID".toLowerCase()
      );
      // alert(datePaidIndex) // Removed the debugging alert
      if (datePaidIndex === -1) return; // Stop if "Date Paid" column isn't found

      rows.forEach(row => {
        const cell = row.cells[datePaidIndex];
        if (cell && cell.textContent.trim().toLowerCase() === "[unpaid]") {
          row.style.backgroundColor = "#ffcccc"; // light red highlight
        }
      });
    });

  </script>
  <title>JO Data Viewer - LAVAR LAUnDRY</title>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      font-size: 10px;
      background-color: #f9f9f9;
      margin: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background-color: #fff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }
    #dataTable td:nth-child(1) { width: 6.88%; }
    #dataTable td:nth-child(2) { width: 2.88%; }
    #dataTable td:nth-child(3) { width: 10.88%; }
    #dataTable td:nth-child(4) { width: .88%; }
    #dataTable td:nth-child(5) { width: 6.88%; }
    #dataTable td:nth-child(6) { width: 1.88%; }
    #dataTable td:nth-child(7) { width: .88%; }
    #dataTable td:nth-child(8) { width: 5.88%; }
    #dataTable td:nth-child(9) { width: 13.88%; }
    #dataTable td:nth-child(10) { width: 8.88%; }
    #dataTable td:nth-child(11) { width: 4.88%; }
    #dataTable td:nth-child(12) { width: 5.88%; }
    #dataTable td:nth-child(13) { width: 9.88%; }
    #dataTable td:nth-child(14) { width: 7.88%; }
    #dataTable td:nth-child(15) { width: 3.88%; }
    #dataTable td:nth-child(16) { width: 3.88%; }
    #dataTable td:nth-child(17) { width: 3.88%; }

    /* Modal backdrop */
    #imageModal {
      display: none;
      position: fixed;
      z-index: 999;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
    }

    /* Modal content */
    #imageModalContent {
      margin: 10% auto;
      display: block;
      max-width: 90%;
      max-height: 80vh;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    }

    #imageModalClose {
      position: absolute;
      top: 20px;
      right: 40px;
      color: white;
      font-size: 30px;
      font-weight: bold;
      cursor: pointer;
    }


    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    th {
      background-color: #003366;
      color: white;
      font-weight: bold;
      position: sticky;
      top: 0;
      z-index: 2;
      cursor: pointer;
    }
    th.sort-asc::after { content: " â–²"; font-size: 12px; }
    th.sort-desc::after { content: " â–¼"; font-size: 12px; }
    tr:nth-child(even) { background-color: #f5f5f5; }
    #status { margin-top: 10px; font-style: italic; color: #333; }
    button {
      padding: 6px 12px;
      font-size: 10px;
      font-family: 'Roboto', sans-serif;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background-color: #45a049; }
    img {
      max-width: 50px;
      max-height: 50px;
      border-radius: 4px;
    }
    #controls { margin-top: 10px; margin-bottom: 10px; }
    #maxDaysInput, #searchDate, #searchCustomer {
      padding: 4px;
      font-size: 10px;
    }
    #searchContainer { margin-top: 10px; }
    /* Updated styles to manage button placement in the flow */
    #clearFiltersButton {
      margin-left: 10px;
      background-color: #f44336;
    }
    #clearTableRows {
      margin-left: 10px;
      background-color: #f44336;
    }
    #clearFiltersButton:hover { background-color: #e53935; }
    .editable-cell {
      cursor: pointer;
    }

    .editable-cell input {
      padding: 2px;
      font-size: 0.9rem;
    }

    .editable-cell button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
    }

    /* Column visibility styles are removed for now to ensure all columns render for debugging */

  </style>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
</head>
<body>
  <div id="imageModal" style="display:none; position:fixed; z-index:9999; left:0; top:0; width:100%; height:100%; overflow:auto; background-color: rgba(0,0,0,0.8);">
    <span id="imageModalClose" style="position:absolute; top:20px; right:35px; color:white; font-size:40px; font-weight:bold; cursor:pointer;">&times;</span>
    <img id="imageModalContent" style="margin:auto; display:block; max-width:90%; max-height:90%; margin-top:5%;" />
  </div>
  <div a>
    <a href="pickuprequestsummary.html"> Requests Summary </a> |
    <a href="pickuprequest.html"> Request Forms </a> |
    <a href="pickup.html"> Pickup </a> |
    <a href="delivery.html"> Delivery </a> |
    <a href="deliverysummary.html"> DVS </a> |
    <a href="LavarFormSubmission.html"> Fold | </a>
    <a href="FoldSite.html"> Fold Site </a>
    <br>
    <br>
  </div>
  <br>
  <br>
  <button onclick="loadData()">Load Data</button>
  <button onclick="triggerCSVImport()">ðŸ“¥ Import CSV</button>
  <button type="button" onclick="window.open('customer_issues.html', 'CustomerIssues', 'width='+ (window.innerWidth * 0.8) + ',height=' + (window.innerHeight * 0.8) + ',left=' + (window.innerWidth * 0.1) + ',top=' + (window.innerHeight * 0.1))">
    View Customer Issues
  </button>

  <button id="filterUnpaidNoDeliveryType">Unpaid Undelivered</button>
  <button id="filterUnpaidDelivered">Unpaid Delivered</button>
  <button id="filterReportedUnpaid">Reported Unpaid</button>
  <div id="controls">
    Max Rows: <input type="number" id="maxDaysInput" value="90" min="1" max="10000">
  </div>


  <div id="searchContainer">
    <label for="searchDate">Search by Date:</label>
    <input type="date" id="searchDate" onchange="filterData()">
    <label for="searchCustomer">Search by Customer:</label>
    <select id="searchCustomer" onchange="filterData()">
      <option value="">Select Customer</option>
    </select>
    <label for="searchDatePaid">Date Paid Status:</label>
    <select id="searchDatePaid" onchange="filterData()">
      <option value="">All</option>
      <option value="[UNPAID]">[UNPAID]</option>
    </select>
    <label for="searchPaymentDeliveryType">Delivery Payment Type:</label>
    <select id="searchPaymentDeliveryType" onchange="filterData()">
      <option value="">All</option>
    </select>
    <label for="searchPaymentMethod">POS Payment Method:</label> <select id="searchPaymentMethod" onchange="filterData()">
      <option value="">All</option>
    </select>
    <label for="searchReported">Reported Status:</label>
    <select id="searchReported" onchange="filterData()">
      <option value="">All</option>
      <option value="[UNREPORTED]">Unreported</option>
    </select>
    <button id="clearFiltersButton" onclick="clearFilters()">Clear Filters</button>
    <button id="clearTableRows" onclick="clearTableRows()">Clear Table</button>
  </div>

  <div id="status"></div>
  <div id="tableContainer"></div>

  <script>
    //SummaryPageHTML - appscript
    //https://script.google.com/macros/s/AKfycbx6fziX1510VRFveZ4hfvGfknrryGgQ85S5AjnvV1g2Ja6pciGz4XSyar2yU-aF2QAw/exec
    const apiUrl = "https://script.google.com/macros/s/AKfycbx6fziX1510VRFveZ4hfvGfknrryGgQ85S5AjnvV1g2Ja6pciGz4XSyar2yU-aF2QAw/exec";
    let allData = [];
    let filteredData = [];
    let deliveryPaymentTypeIndex = -1; 
    let paymentMethodIndex = -1; 

    function formatDateTime(input) {
      const date = new Date(input);
      if (isNaN(date)) return input;


      date.setHours(date.getHours());

      return new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      }).format(date).replace(',', '');
    }

    function formatDateOnly(input) {
      const date = new Date(input);
      if (isNaN(date)) return input;
      return date.toISOString().slice(0, 10); // YYYY-MM-DD
    }
    
    // Function to open the image modal
    function openImageModal(imageUrl) {
        const modal = document.getElementById("imageModal");
        const modalImg = document.getElementById("imageModalContent");
        modal.style.display = "block";
        modalImg.src = imageUrl;
    }

    function renderTable(data) {
      const container = document.getElementById("tableContainer");
      const maxDays = parseInt(document.getElementById("maxDaysInput").value) || 30;
      container.innerHTML = "";

      const table = document.createElement("table");
      table.id = "dataTable";
      const headers = data[0];
      console.log("Headers:", headers); // Debugging: Log the headers

      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      headers.forEach((header, index) => {
        const th = document.createElement("th");
        th.textContent = header;
        th.onclick = () => {
          const isAscending = !th.classList.contains("sort-asc");
          [...thead.querySelectorAll("th")].forEach(h => h.classList.remove("sort-asc", "sort-desc"));
          th.classList.toggle("sort-asc", isAscending);
          th.classList.toggle("sort-desc", !isAscending);
          sortTable(table, index, isAscending);
        };
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (let i = 1; i < Math.min(data.length, 10000); i++) {
        const rowData = data[i];
        const row = document.createElement("tr");
        row.id = rowData[1];  // Use JO# as row ID
        rowData.forEach((cell, index) => {
          const td = document.createElement("td");

          if (index === 0 || index === 4 || index === 16 || index === 20) { // DATE CREATED, DATE PAID, Fold Date, Time of Delivery
            td.textContent = formatDateTime(cell);
          } else if (index === 15) { // Fold Date
            td.textContent = formatDateOnly(cell);
          } 
          // CORRECTED IMAGE INDEXES: 8 (Pickup Pic), 9 (DropMedia1), 10 (DropMedia2), 20 (media), 21 (media2), 22 (media3)
          else if ([8, 9, 10, 21, 22, 23].includes(index)) { 
            if (typeof cell === "string" && cell.includes("drive.google.com")) {
              const match = cell.match(/\/d\/([a-zA-Z0-9_-]+)\//);
              if (match && match[1]) {
                const fileId = match[1];
                // Use the correct thumbnail and view URLs
                const thumbUrl = `https://drive.google.com/thumbnail?id=${fileId}`;
                const fullImageUrl = `https://drive.google.com/uc?export=view&id=${fileId}`;

                const img = document.createElement("img");
                img.src = thumbUrl;
                img.alt = "Image";
                img.style.maxWidth = "80px";
                img.style.cursor = "pointer";

                // Use the defined openImageModal function for a consistent experience
                img.onclick = () => {
                    openImageModal(fullImageUrl);
                };

                td.appendChild(img);
              } else {
                td.textContent = "Invalid link";
              }
            } else {
              td.textContent = "";
            }

          } else if (index === 1) { // JO# column
            const a = document.createElement("a");
            a.href = "#";
            a.textContent = cell ?? "N/A";
            a.style.cursor = "pointer";
            a.style.color = "#0066cc";
            a.style.textDecoration = "underline";

            a.onclick = (e) => {
              e.preventDefault();
              const joNumber = cell; // e.g., "#12669"
              const customerName = rowData[2] || ""; // CUSTOMER is column index 2
              const encodedJO = encodeURIComponent(joNumber);
              const encodedCustomer = encodeURIComponent(customerName);
              const width = 600;
              const height = 400;
              const left = (window.screen.width / 2) - (width / 2);
              const top = (window.screen.height / 2) - (height / 2);

              window.open(
                `JOpopup.html?joNumber=${encodedJO}&customer=${encodedCustomer}`,
                "JOpopupWindow",
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
              );

            };

            td.appendChild(a);

          } else {
            td.textContent = cell ?? "";
          }
          row.appendChild(td);
        });

        tbody.appendChild(row);
      }

      table.appendChild(tbody);
      container.appendChild(table);
      setTimeout(() => {
        markJOIssuesInTable();
      }, 0);
    }

    // Add sorting functionality
    function sortTable(table, colIndex, ascending = true) {
      const rows = Array.from(table.rows).slice(1);
      rows.sort((a, b) => {
        const valA = a.cells[colIndex].textContent.trim();
        const valB = b.cells[colIndex].textContent.trim();
        const dateA = new Date(valA);
        const dateB = new Date(valB);
        if (!isNaN(dateA) && !isNaN(dateB)) {
          return ascending ? dateA - dateB : dateB - dateA;
        }
        return ascending ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
      rows.forEach(row => table.appendChild(row));
    }
    // Load data from the API
    async function loadData() {
      const status = document.getElementById("status");
      status.textContent = "Loading...";
      try {
        const response = await fetch(apiUrl);
        const data = await response.json();
        allData = data;
        filteredData = data;

        const headers = allData[0];
        
        // Find index for "Delivery Payment Type" (Index 18)
        deliveryPaymentTypeIndex = headers.findIndex(
          header => header.trim().toLowerCase() === "Delivery Payment Type".toLowerCase()
        );
        
        // Find index for "Payment Method" (Index 5)
        paymentMethodIndex = headers.findIndex(
            header => header.trim().toLowerCase() === "PAYMENT METHOD".toLowerCase()
        );

        renderTable(filteredData);
        addUnresolvedWarnings();
        loadCustomers(data);
        loadPaymentDeliveryTypes(data); // Call the existing function
        loadPaymentMethods(data); // Call the new function to load payment methods
        loadReportedDates(data); // Call the existing function to load reported dates
        status.textContent = "";
      } catch (e) {
        status.textContent = "Error loading data: " + e.message;
      }
    }

    // Load customers into the dropdown
    function loadCustomers(data) {
      const select = document.getElementById("searchCustomer");
      const customerSet = new Set();

      data.slice(1).forEach(row => {
        let customer = (row[2] || "").trim(); // Index 2
        if (customer) customerSet.add(customer);
      });


      select.innerHTML = '<option value="">Select Customer</option>';

      // Sort alphabetically, case-insensitive
      [...customerSet].sort((a, b) => a.localeCompare(b, undefined, {
        sensitivity: 'base'
      }))
        .forEach(name => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        });
    }

    // Load Payment/Delivery Types into the dropdown dynamically
    function loadPaymentDeliveryTypes(data) {
      const select = document.getElementById("searchPaymentDeliveryType");
      const typeSet = new Set();
      const headers = data[0];
      // Use the correct index 18
      const deliveryPaymentTypeIndex = headers.findIndex(
        header => header.trim().toLowerCase() === "Delivery Payment Type".toLowerCase()
      );

      if (deliveryPaymentTypeIndex === -1) {
        console.error("Delivery Payment Type column not found.");
        return;
      }

      data.slice(1).forEach(row => {
        let type = (row[deliveryPaymentTypeIndex] || "").trim();
        if (type) typeSet.add(type);
      });

      select.innerHTML = '<option value="">All</option>';

      // Hardcoded values to be included regardless of data
      const fixedOptions = ["Cash", "G-Cash", "Other Online Payment", "Pick Up"];
      fixedOptions.forEach(type => {
        typeSet.add(type);
      });

      // Sort alphabetically, case-insensitive
      [...typeSet].sort((a, b) => a.localeCompare(b, undefined, {
        sensitivity: 'base'
      }))
        .forEach(type => {
          const opt = document.createElement("option");
          opt.value = type;
          opt.textContent = type;
          select.appendChild(opt);
        });
    }

    // NEW FUNCTION: Load Payment Methods into the dropdown dynamically
    function loadPaymentMethods(data) {
        const select = document.getElementById("searchPaymentMethod");
        const methodSet = new Set();
        const headers = data[0];
        // Use the correct index 5
        const paymentMethodIndex = headers.findIndex(
            header => header.trim().toLowerCase() === "PAYMENT METHOD".toLowerCase()
        );

        if (paymentMethodIndex === -1) {
            console.error("PAYMENT METHOD column not found.");
            return;
        }

        data.slice(1).forEach(row => {
            if (paymentMethodIndex !== -1) {
                const method = (row[paymentMethodIndex] || "").trim();
                if (method) methodSet.add(method);
            }
        });

        select.innerHTML = '<option value="">All</option>';

        // Sort alphabetically, case-insensitive
        [...methodSet].sort((a, b) => a.localeCompare(b, undefined, {
            sensitivity: 'base'
        }))
            .forEach(method => {
                const opt = document.createElement("option");
                opt.value = method;
                opt.textContent = method;
                select.appendChild(opt);
            });
    }

    // New function to load unique dates from the "Reported" column
    function loadReportedDates(data) {
      const select = document.getElementById("searchReported");
      const headers = data[0];
      // Use the correct index 28
      const reportedIndex = headers.findIndex(header => header.trim().toLowerCase() === "REPORTED".toLowerCase());

      if (reportedIndex === -1) {
        console.error("Reported column not found.");
        return;
      }

      const dateSet = new Set();
      data.slice(1).forEach(row => {
        const date = (row[reportedIndex] || "").trim();
        if (date) {
          dateSet.add(date);
        }
      });

      // Clear existing options
      select.innerHTML = '<option value="">All</option><option value="[UNREPORTED]">Unreported</option>';

      // Sort dates
      const sortedDates = Array.from(dateSet).sort((a, b) => new Date(a) - new Date(b));

      sortedDates.forEach(date => {
        const opt = document.createElement("option");
        opt.value = date;
        opt.textContent = date;
        select.appendChild(opt);
      });
    }

    // Filter data based on date and customer
    function filterData() {

      const searchDate = document.getElementById("searchDate").value; // Date picker value
      const searchCustomer = document.getElementById("searchCustomer").value.trim().toLowerCase(); // Normalize input
      const datePaidFilter = document.getElementById("searchDatePaid").value;
      const deliveryTypeFilter = document.getElementById("searchPaymentDeliveryType").value.trim().toLowerCase();
      const paymentMethodFilter = document.getElementById("searchPaymentMethod").value.trim().toLowerCase(); // Get POS Payment Method filter value
      const reportedFilter = document.getElementById("searchReported").value;
      const headers = allData[0];
      
      // Get correct indices by header text
      const deliveryPaymentTypeIndex = headers.findIndex(
          header => header.trim().toLowerCase() === "Delivery Payment Type".toLowerCase()
      );
      const datePaidIndex = headers.findIndex(
          header => header.trim().toLowerCase() === "DATE PAID".toLowerCase()
      );
      const reportedIndex = headers.findIndex(
          header => header.trim().toLowerCase() === "REPORTED".toLowerCase()
      );
      const paymentMethodIndex = headers.findIndex( // Index 5
          header => header.trim().toLowerCase() === "PAYMENT METHOD".toLowerCase()
      );


      // Convert the search date from yyyy-mm-dd to yyyyMMdd format
      const formattedSearchDate = searchDate.split('-').join(''); // e.g., '2025-05-14' -> '20250514'

      console.log("Formatted Search Date:", formattedSearchDate); // Debugging: Log the selected date

      filteredData = allData.filter((row, index) => {
        if (index === 0) return true; // Keep header row

        let isMatch = true;

        // If a date is selected (Index 0)
        if (searchDate) {
          const rawDate = row[0] || ""; 
          const dateObj = new Date(rawDate);
          const formattedRowDate = `${dateObj.getFullYear()}${(dateObj.getMonth() + 1).toString().padStart(2, '0')}${dateObj.getDate().toString().padStart(2, '0')}`;

          if (formattedRowDate !== formattedSearchDate) {
            isMatch = false; 
          }
        }

        // If a customer filter is selected (Index 2)
        if (searchCustomer) {
          const customer = (row[2] || "").trim().toLowerCase(); 
          if (customer !== searchCustomer) isMatch = false;
        }

        // If the date paid filter is selected (Index 4)
        if (datePaidFilter && datePaidIndex !== -1) {
          const datePaid = (row[datePaidIndex] || "").trim();
          if (datePaid !== datePaidFilter) isMatch = false;
        }

        // If the delivery type filter is selected (Index 18)
        if (deliveryTypeFilter && deliveryPaymentTypeIndex !== -1) {
          const deliveryType = (row[deliveryPaymentTypeIndex] || "").trim().toLowerCase();
          if (deliveryType !== deliveryTypeFilter) isMatch = false;
        }
        
        // If the POS Payment Method filter is selected (Index 5)
        if (paymentMethodFilter && paymentMethodIndex !== -1) {
            const paymentMethod = (row[paymentMethodIndex] || "").trim().toLowerCase();
            if (paymentMethod !== paymentMethodFilter) isMatch = false;
        }

        // If the reported filter is selected (Index 28)
        if (reportedFilter && reportedIndex !== -1) {
            const reportedValue = (row[reportedIndex] || "").trim();
            if (reportedFilter === "[UNREPORTED]") {
                if (reportedValue !== "") isMatch = false;
            } else {
                if (reportedValue !== reportedFilter) isMatch = false;
            }
        }

        return isMatch;
      });

      renderTable(filteredData); // Re-render table
      addUnresolvedWarnings();
    }

    // Clear all rows in the table, keeping the headers intact
    function clearTableRows() {
      const table = document.querySelector("table"); // Select the first table
      const tbody = table.querySelector("tbody"); // Select the tbody (where rows are stored)

      if (tbody) {
        tbody.innerHTML = ""; // Remove all rows in the tbody, keeping the headers intact
      }
    }
    // Clear filters and reset the table to show all data
    function clearFilters() {
      document.getElementById("searchDate").value = "";
      document.getElementById("searchCustomer").value = "";
      document.getElementById("searchDatePaid").value = "";
      document.getElementById("searchPaymentDeliveryType").value = "";
      document.getElementById("searchPaymentMethod").value = ""; // Clear the POS Payment Method filter
      document.getElementById("searchReported").value = "";
      filteredData = allData;
      renderTable(filteredData);
      addUnresolvedWarnings();
    }

    // Close the image modal
    function closeImageModal() {
      const modal = document.getElementById("imageModal");
      modal.style.display = "none";
      document.getElementById("imageModalContent").src = "";
    }
    // Event listener for closing the modal when clicking outside the image
    document.getElementById("imageModalClose").onclick = function () {
      document.getElementById("imageModal").style.display = "none";
    };


    document.getElementById("imageModalClose").onclick = function () {
      document.getElementById("imageModal").style.display = "none";
    };
    //
    window.onclick = function (event) {
      const modal = document.getElementById("imageModal");
      if (event.target === modal) {
        modal.style.display = "none";
      }
    };
    //
    document.querySelectorAll('.save-comment-btn').forEach((button, index) => {
      button.addEventListener('click', () => {
        const row = button.closest('tr');
        const comment = row.querySelector('.comment-input').value.trim();
        const uniqueId = row.getAttribute('data-id');

        if (!comment || !uniqueId) {
          alert("Missing comment or ID");
          return;
        }

        fetch('https://script.google.com/macros/s/YOUR_DEPLOYED_WEBAPP_URL/exec', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            id: uniqueId,
            column: 'Admin Comments',
            value: comment
          })
        })
          .then(res => res.json())
          .then(result => {
            if (result.status === 'success') {
              alert('Comment saved!');
            } else {
              alert('Error: ' + result.message);
            }
          })
          .catch(err => alert('Network error: ' + err.message));
      });
    });

    async function checkUnresolvedIssues(joNumber) {
      // Assuming Unresolved Issues is at index 27
      const unresolvedIssuesIndex = 27; 
      try {
        const response = await fetch(`https://script.google.com/macros/s/AKfycbx1djlMVlkR3nt1_5l2vCVzqahdHjipOPwDXcjo1fc_KtpaWoL4uLF1LoXpPXGpoOw/exec?action=checkIssues&jo=${encodeURIComponent(joNumber)}`);
        const data = await response.json();
        return data.unresolvedCount || 0;
      } catch (err) {
        console.error(`Error checking issues for ${joNumber}:`, err);
        return 0;
      }
    }

    async function markJOIssuesInTable() {
      console.log("markJOIssuesInTable called");
      const rows = document.querySelectorAll("#dataTable tbody tr");
      for (const row of rows) {
        const joCell = row.querySelector("td:nth-child(2)"); // JO# is the 2nd cell (index 1)
        const customerCell = row.querySelector("td:nth-child(3)"); // CUSTOMER is the 3rd cell (index 2)

        if (joCell && customerCell) {
          const joNumber = joCell.textContent.trim();

          // NOTE: If you are relying on a server-side check, this is fine. 
          const unresolvedCount = await checkUnresolvedIssues(joNumber); 
          if (unresolvedCount > 0) {
            customerCell.innerHTML += ` <span title="${unresolvedCount} unresolved issue(s)" style="color: red; font-weight: bold;">&#x26A0;</span>`;
          }
        }
      }
    }



    //ImportCSVRaw
    function triggerCSVImport() {
      if (confirm("Are you sure you want to import the latest CSV? This may overwrite existing data.")) {
        fetch('https://script.google.com/macros/s/AKfycbwDtZ-VC549G9V9K9PD3i8qSFFUL2KUJnXjGFkM_gmspfLXMczyyD4ikNXKbpBtRLOzqA/exec?importCSV=true')
          .then(response => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.text(); // or response.json() if JSON
          })
          .then(data => {
            alert("Success:\n" + data);
            location.reload();
          })
          .catch(error => {
            alert("Error:\n" + error.message);
          });
      }
    }


    function addUnresolvedWarnings() {
      const table = document.querySelector('#dataTable'); // Replace with your actual table ID
      if (!table) return;

      const rows = document.querySelectorAll('#dataTable tbody tr');
      const headers = allData[0];
      const unresolvedIssuesIndex = headers.findIndex(header => header.trim().toLowerCase() === "Unresolved Issues".toLowerCase());

      if (unresolvedIssuesIndex === -1) return;

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length > unresolvedIssuesIndex) {
          const unresolved = parseInt(cells[unresolvedIssuesIndex].textContent) || 0;
          if (unresolved > 0) {
            const customerCell = cells[2]; // Column 3 = CUSTOMER (Index 2)
            if (!customerCell.innerHTML.includes('âš ï¸')) {
              customerCell.innerHTML = customerCell.innerHTML + 'âš ï¸ ';
              customerCell.style.color = 'red';
              customerCell.style.fontWeight = 'bold';
              customerCell.title = `${unresolved} unresolved issue${unresolved > 1 ? 's' : ''}`;
            }
          }
        }
      });
    }
    // Load data on page load
    window.onload = function () {
      loadData();
    };


    document.addEventListener("DOMContentLoaded", function () {
      const table = document.querySelector("#tableContainer #dataTable");
      if (!table) return;

      const rows = table.querySelectorAll("tbody tr");

      // Get the index of the "Date Paid" column (case-insensitive)
      const headers = Array.from(table.querySelectorAll("thead th"));
      const datePaidIndex = headers.findIndex(
        th => th.textContent.trim().toLowerCase() === "DATE PAID".toLowerCase()
      );
      // alert(datePaidIndex) // Removed the debugging alert
      if (datePaidIndex === -1) return; // Stop if "Date Paid" column isn't found

      rows.forEach(row => {
        const cell = row.cells[datePaidIndex];
        if (cell && cell.textContent.trim().toLowerCase() === "[unpaid]") {
          row.style.backgroundColor = "#ffcccc"; // light red highlight
        }
      });
    });

    document.getElementById("filterUnpaidNoDeliveryType").addEventListener("click", function () {
      const table = document.getElementById("dataTable");
      const tbody = table.querySelector("tbody");
      const rows = tbody.querySelectorAll("tr");
      const headers = allData[0];
      const datePaidIndex = headers.findIndex(header => header.trim().toLowerCase() === "DATE PAID".toLowerCase());
      const deliveryPaymentTypeIndex = headers.findIndex(header => header.trim().toLowerCase() === "Delivery Payment Type".toLowerCase()); // Index 18

      rows.forEach(row => {
        const cells = row.querySelectorAll("td");

        const datePaid = (cells[datePaidIndex]?.textContent || "").trim();
        const deliveryType = (cells[deliveryPaymentTypeIndex]?.textContent || "").trim();

        const isUnpaid = datePaid === "[UNPAID]";
        const isDeliveryTypeBlank = deliveryType === "";

        if (isUnpaid && isDeliveryTypeBlank) {
          row.style.display = "";
        } else {
          row.style.display = "none";
        }
      });
    });

    document.getElementById("filterUnpaidDelivered").addEventListener("click", function () {
      const table = document.getElementById("dataTable");
      const tbody = table.querySelector("tbody");
      const rows = tbody.querySelectorAll("tr");
      const headers = allData[0];
      const datePaidIndex = headers.findIndex(header => header.trim().toLowerCase() === "DATE PAID".toLowerCase());
      // Assuming 'Delivered' is represented by 'Time of Delivery' (Index 21) being non-blank.
      const timeOfDeliveryIndex = headers.findIndex(header => header.trim().toLowerCase() === "Time of Delivery".toLowerCase()); 

      rows.forEach(row => {
        const cells = row.querySelectorAll("td");

        const datePaid = (cells[datePaidIndex]?.textContent || "").trim(); 
        const deliveredColumn = (cells[timeOfDeliveryIndex]?.textContent || "").trim(); 

        const isUnpaid = datePaid === "[UNPAID]";
        const hasDeliveredValue = deliveredColumn !== "";

        if (isUnpaid && hasDeliveredValue) {
          row.style.display = "";
        } else {
          row.style.display = "none";
        }
      });
    });

    // NEW FUNCTIONALITY FOR "Reported Unpaid" BUTTON
    document.getElementById("filterReportedUnpaid").addEventListener("click", function () {
      const table = document.getElementById("dataTable");
      const tbody = table.querySelector("tbody");
      const rows = tbody.querySelectorAll("tr");
      const headers = allData[0];
      
      // Get column indices
      const datePaidIndex = headers.findIndex(header => header.trim().toLowerCase() === "DATE PAID".toLowerCase());
      const reportedIndex = headers.findIndex(header => header.trim().toLowerCase() === "REPORTED".toLowerCase()); // Index 28

      // Check if both columns exist
      if (datePaidIndex === -1 || reportedIndex === -1) {
          console.error("Required columns (DATE PAID or REPORTED) not found for filter.");
          return;
      }

      // Filter rows
      rows.forEach(row => {
        const cells = row.querySelectorAll("td");

        // Get values from the respective cells using the stored indices
        const datePaid = (cells[datePaidIndex]?.textContent || "").trim();
        const reportedValue = (cells[reportedIndex]?.textContent || "").trim();

        // Condition 1: Date Paid is [UNPAID]
        const isUnpaid = datePaid === "[UNPAID]";
        
        // Condition 2: Reported column has a value (a date, not blank)
        const isReported = reportedValue !== "";

        if (isUnpaid && isReported) {
          row.style.display = ""; // Show row
        } else {
          row.style.display = "none"; // Hide row
        }
      });
    });

  </script>

  <div id="imageModal" onclick="closeImageModal()">
    <span id="imageModalClose">&times;</span>
    <img id="imageModalContent" src="" alt="Full Image">
  </div>
</body>
</html>